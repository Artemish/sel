\input texinfo
@c @setfilename emacs-web-server.info
@documentencoding utf-8
@settitle Software Evolution Library

@copying
This file documents the Software Evolution library

Copyright (C) 2014 Eric Schulte <eschulte@@cs.unm.edu>

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being ``GNU GENERAL PUBLIC LICENSE,''
A copy of the license is included in the section entitled
``GNU Free Documentation License.''
@end quotation
@end copying

@dircategory Libraries
@direntry
* Software Evolution: (software-evolution-library). library enabling extant software evolution
@end direntry

@titlepage
@title Software Evolution Library
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Software Evolution Library

@insertcopying
@end ifnottex


Software Evolution Library (SEL) is a Common Lisp library for using
evolutionary search to programmatically modify and evaluate software.
It provides a common interface which abstracts over several kinds of
software objects including parsed abstract syntax trees, intermediate
languages, compiled assembler, or binaries.

Methods for evolution, mutation, crossover, and fitness evaluation are
implemented on top of this interface, supporting Search Based Software
Engineering (SBSE) techniques.


@menu
* Introduction::                What's it for?
* Implementation::              How's it implemented?
* Components::                  What's it provide?
* Usage::                       How's it used?
* SEL API Reference::           Full API reference including usage guidelines.
* Troubleshooting::             FIXME

Included Libraries
* Utility::                     Utility functions.
* View::                        Interactive user interface.
* Test::                        Unit tests.

Appendices
* General Lisp Advice::
* SEL Coding Standards::
* Licensing::
* Index::                       Complete index.

@end menu



@node Introduction, Implementation, Top, Top
@chapter Introduction
@cindex introduction


The Software Evolution library enables the programmatic modification
and evaluation of extant software.  The software evolution library was
developed as part of the genprog project on automated program repair.

A common interface abstracts over multiple types of software objects
(@pxref{Software Objects}) including abstract syntax trees parsed from
source code, LLVM IR, compiled assembler, and linked ELF binaries.
Mutation and evaluation methods (@pxref{Software Methods}) are
implemented on top of this interface supporting Search Based Software
Engineering (SBSE) techniques (@pxref{Search Functions}).

This library has been used to optimize benchmark programs (see
@url{https://github.com/eschulte/goa}) and to patch vulnerabilities in
closed source binaries (see
@url{http://eschulte.github.io/netgear-repair}).


@section How is it used?

SEL has a broad range of applications for software improvement and
understanding. The following are some current and past projects
utilizing SEL.

@itemize

@item
Optimizing real-world software
(@url{https://github.com/eschulte/goa,github.com/eschulte/goa}).

@item

Patching vulnerabilities in closed source binaries
(@url{http://eschulte.github.io/netgear-repair,eschulte.github.io/netgear-repair}).

@item
Filling "holes" in incomplete programs whose behavior is partially
specified by unit tests and developer hints
(@url{http://cs.unm.edu/~eschulte/data/musynth-ssbse-2017.pdf,MuSynth}).

@item
Adapting  software for
@url{https://www.darpa.mil/program/building-resource-adaptive-software-systems,DARPA's BRASS program}.

@item
Injecting bugs into software to create cyber-defense benchmarks
(@url{https://www.grammatech.com/sponsored-research,BUG-INJECTOR}).

@item
Decompiling binaries to C source FIXME LINK.

@item
Studying the @emph{mutational robustness} of software
(@url{http://cs.unm.edu/~eschulte/dissertation/,cs.unm.edu/~eschulte/dissertation}).

@end itemize


@section What kinds of software can be manipulated?

The SEL API defines software objects using the Common Lisp Object
System (CLOS), to provide a uniform interface to many kinds of
software artifact.

SEL currently provides implementations of software objects
representing a range of different software artifacts types, shown in
the table below.

Additionally, the flexible design of SEL makes it possible to add new
software object kinds. Refer to the documentation FIXME LINK for
information about creating new software objects.


@multitable {compiled assembler  ASM  } {experimental}
@item C and C++ source         @tab mature
@item compiled assembler (ASM) @tab mature
@item linked ELF binaries      @tab mature
@item LLVM IR                  @tab experimental
@item CIL                      @tab experimental
@item LISP                     @tab experimental
@item Forth                    @tab experimental
@item Java                     @tab @emph{forthcoming}
@item Coq                      @tab @emph{forthcoming}
@end multitable


@section What other features are provided?

SEL provides support for exploring many different aspects of both
evolutionary search and automated software manipulation. 

@itemize

@item
Multiple evolution techniques including generational or Monte Carlo
Markov chain.

@item
New mutations tailored to each software object.

@item
One- and two-point crossover.

@item
Lexicase or multi-objective fitness evaluations.

@item
Instrumentation of software objects and dynamic trace collection.

@item
Use of "fodder databases" as a source of new statements or expressions
that can be injected by mutations.

@item
Ancestry for candidate solutions.

@item
Adaptive mutations to dynamically update probabilities based on
mutation success.

@end itemize


@subheading Tailored feautures for for C/C++ objects

@itemize

@item
Automatic repair for some compilation errors and warnings.

@item
Special mutations for renaming variables, changing loops, and
otherwise manipulating statements.

@item
Spectrum-based fault localization, which instruments source code and
runs (passing and failing) unit tests to attempt to locate errors.

@item
Condition synthesis, a repair technique 
@url{http://groups.csail.mit.edu/pac/patchgen/papers/spr-fse15.pdf, described by Long and Rinard}
which tries to synthesize conditional statements that will correct
source code so that it passes failing unit tests.

@end itemize



@section That sounds awesome! How do I get started?


First, @ref{Installation, install SEL and its dependencies}.

Once SEL is installed, try out some of the @ref{Examples, example code}.

If you are ready to try using SEL in your own code, consult the API documentation FIXME LINK.

If you have questions, please refer to the [FAQ](FAQ.html) to make
sure your question hasn't already been answered before reporting an
issue.

@subsection Citing

Please cite Eric Schulte's Ph.D. dissertation when you publish results
that you have obtained with the SOFTWARE EVOLUTION library (see
@cite{Neutral Networks of Real-World Programs and their Application to
Automated Software Evolution} available at
@url{https://cs.unm.edu/~eschulte/dissertation}).



@node Implementation, Software Objects, Introduction, Top
@chapter Implementation
@cindex implementation

The Software Evolution library is implemented in Common Lisp and is
intended for use in Common Lisp programs.  @ref{fig:overview} provides
an overview of the Software Evolution system, the specifics of which
are given in remainder of this section.

@menu
* Software Objects::            Representation of software
* Software Methods::            Manipulation of software
* Global Variables::            Interface to search processes
* Search Functions::            High level functions to perform search
@end menu

@float Figure,fig:overview
@example
                                                      population functions
 global variables                                     --------------------
 ----------------        +------------------+         incorporate
 *population*            |   *population*   |         evict
 *max-population-size*   |------------------|         tournament
 *tournament-size*       |      list of     |         mutate
 *fitness-predicate*     | software objects |         new-individual
 *cross-chance*          +------------------+         evolve
 *fitness-evals*                  |                   mcmc
 *running*                      +-+-+
                                | | |                 software functions
                         +------------------+         --------------
 evolve arguments        | software object  |         genome
 ----------------        |------------------|         phenome
 max-evals               | edits,           |         copy
 max-time                | fitness          |         pick-good
 target                  | ...              |         pick-bad
 period                  +------------------+         mutate
 period-func                 |     |                  crossover
 filter      +---------------+     |
             | +---------------+---+-----+------+----------------+
+------------+ |               |         |      |                |
|     +---------------+  +-------------+ | +-------------+  +------------+
|     |      AST      |  |     ELF     | | |    lisp     |  |    asm     |
|     |---------------|  |-------------| | |-------------|  |------------|
|     |   Abstract    |  | Executable  | | | lisp source |  |  assembly  |
|     |  Syntax Tree  |  |  Linkable   | | +-------------+  |    code    |
|     +---------------+  |   Format    | |                  +------------+
|             |          +-------------+ +--------+             |
|    +--------------+-------------------+         |   +------------------+
|    |              |                   |         |   |     asm-range    |
| +-------+  +----------------+   +----------+    |   |------------------|
| | Clang |  |       CIL      |   |   LLVM   |    |   | memory efficient |
| |-------|  |----------------|   |----------|    |   +------------------+
| | C AST |  | C Intermediate |   | LLVM IR  |  +--------------+
| +-------+  |    Language    |   +----------+  |    forth     |
|    |       +----------------+                 |--------------|
|    +------------------------------+           | forth source |
+---------------------+             |           +--------------+
                      |             |
                +------------+     +-------------------+
                | Searchable |  +--| Clang with Fodder |
                +------------+  |  +-------------------+
                      |   +-----+
                      |   |
            +-----------------+  +--------------------+
         +--| Fodder Database |--| In Memory Database |
         |  +-----------------+  +--------------------+
         |            |                    |
    +----------+ +----------+         +---------+
    | Pliny DB | | Mongo DB |         | JSON DB |
    +----------+ +----------+         +---------+
@end example
@caption{Software Evolution API.  Exported functions and variables are
shown along with the software object class hierarchy.}
@end float

@node Software Objects, Software Methods, Implementation, Implementation
@section Software Objects
@cindex software objects

The following types of software objects are supported.

@deftp Class asm fitness genome addr-map linker flags
General assembler backend used to manipulate @code{.s} text assembler.
@end deftp

@deftp Class cil fitness genome flags compiler ext raw-size
C abstract syntax trees using C Intermediate Language (CIL) (see
@url{http://kerneis.github.io/cil/}).
@end deftp

@deftp Class clang fitness genome flags compiler ext raw-size
C language (including @code{C}, @code{C++}, @code{C#}, etc...)
abstract syntax trees using the C Language frontend for LLVM (see
@url{http://clang.llvm.org/}).
@end deftp

@deftp Class llvm fitness genome flags compiler ext raw-size ext linker
Low Level Virtual Machine (LLVM) (see @url{http://llvm.org})
intermediate representation (IR).
@end deftp

@deftp Class elf-mips fitness genome base
Executable Linkable Format (ELF) binaries in MIPS architectures.
@end deftp

@deftp Class elf-cisc fitness genome base addresses
Executable Linkable Format (ELF) binaries in complex instruction set architectures.
@end deftp

@deftp Class lisp fitness genome
Common Lisp source code.
@end deftp

@node Software Methods, Global Variables, Software Objects, Implementation
@section Software Methods
@cindex software methods

The following methods are defined for all software object types
exposing a common interface for use by user programs or in heuristic
search.

@anchor{genome}
@defun genome software
The software genotype or ``code'', exposed as a simplified data
structure.  For example an AST genome, e.g., of a @code{cil} or
@code{lisp} software object, my have a tree structure while the genome
of a @code{asm} or @code{elf} software object will be a vector.
@end defun


@anchor{phenome}
@defun phenome software &key bin
The software phenotype.  This method will link, compile or serialize
the software object as necessary returning an executable version of
the software suitable for testing and evaluation
@end defun

@anchor{copy}
@defun copy software
Return a deep copy of a software object.
@end defun

@anchor{pick}
@defun pick software key &optional func
Randomly select elements of the genome of @code{SOFTWARE}.  Selection
may optionally be biased towards particular portions of the genome
based on a @code{key} supplied to @code{pick}.  Related
@code{pick-good} and @code{pick-bad} methods may also be customized.
Useful for e.g., using annotations or fault localization information
to bias mutation operations.
@end defun

@anchor{mutate}
@defun mutate software
Randomly mutate the supplied software object.  The modified software
object and the applied mutation are returned.
@end defun

@anchor{crossover}
@defun crossover software-a software-b
Perform the specified form of crossover on two software objects
returning a new software object and information on the crossover
operation performed (e.g., the indices of crossover).  The related
@code{one-point-crossover} and @code{two-point-crossover} methods may
also be used to perform particular types of crossover.
@end defun

@anchor{from-file}
@defun from-file software file
Initialize a software object @code{SOFTWARE} using the contents of
@code{FILE}.
@end defun

@anchor{to-file}
@defun to-file software file
Write the genome of software object @code{SOFTWARE} to @code{FILE}.
@end defun

@node Global Variables, Search Functions, Software Methods, Implementation
@section Global Variables
@cindex Global Variables

The following global variables are exposed for configuration and
interaction with heuristic search processes.


@anchor{*population*}
@defvar *population*
A list of the software objects currently known to the system.  This
variable may be read to inspect a running search process, or written
to as part of a running search process.
@end defvar

@anchor{*max-population-size*}
@defvar *max-population-size*
Maximum allowable population size.
@end defvar

@anchor{*tournament-size*}
@defvar *tournament-size*
Number of individuals to participate in tournament selection.  Default
value is ``@code{2}''.
@end defvar

@anchor{*tournament-eviction-size*}
@defvar *tournament-eviction-size*
Number of individuals to participate in eviction tournaments.  Default
value is ``@code{2}''.
@end defvar

@anchor{*tournament-selector*}
@defvar *tournament-selector*
Function used to select winners of a tournament. Returns a list of the
best candidates.  Default  value is ``@code{#'default-select-best}''.
@end defvar

@anchor{*tournament-tie-breaker*}
@defvar *tournament-tie-breaker*
Function used to break ties when a tournament has multiple
winners. Returns a single winner.  Default value is
``@code{#'default-random-winner}''.
@end defvar

@anchor{*tie-breaker-predicate*}
@defvar *tie-breaker-predicate*
Function to compare two tie breaker values to select which is
preferred.  Default value is ``@code{#'>}''.
@end defvar

@anchor{*fitness-predicate* }
@defvar *fitness-predicate*
Function to compare two fitness values to select which is preferred.
Default value is ``@code{#'>}''.
@end defvar

@anchor{*cross-chance*}
@defvar *cross-chance*
Fraction of new individuals generated using crossover rather than
mutation.  Default value is ``@code{2/3}''.
@end defvar

@anchor{*mut-rate*}
@defvar *mut-rate*
Chance to mutate a new individual. If value is less than 1 then new
individuals will be mutated once with change @code{*MUT-RATE*}.  If
value is equal to 1, then every new individual will be mutated exactly
once.  If value is greater than 1, then new individuals will be
mutated from 1 to *MUT-RATE* times.  Default value is ``@code{1}''.
@end defvar

@anchor{*fitness-evals*}
@defvar *fitness-evals*
This variable tracks the total number of fitness evaluations
performed.
@end defvar

@anchor{*running*}
@defvar *running*
True when a search process is running, set this variable to nil to
stop a running search.
@end defvar

@node Search Functions, Components, Global Variables, Implementation
@section Search Functions
@cindex search functions

Currently two high-level search functions are implemented.  The
@code{evolve} search function has received much more testing and is
recommended.

@anchor{evolve}
@defun evolve test &key max-evals max-time target period period-fn every-fn filter
Evolve the existing @code{*population*} of software objects using the
supplied @code{TEST} function to evaluate the fitness of software
objects.  The fitness returned by the @code{TEST} function is
optimized.  A steady state evolutionary computation algorithm is used
to evolve increasingly fit software objects in a process resembling
natural selection.
@end defun

@anchor{mcmc}
@defun mcmc original test &key accept-fn max-evals max-time target period period-fn every-fn filter
Preform Markov chain Monte Carlo search from the supplied
@code{ORIGINAL} software object using the supplied @code{TEST}
function to evaluate the fitness of software objects.  The fitness
returned by the @code{test} function is optimized.
@end defun

Both functions take the following optional keyword arguments

@table @code
@item max-evals
stop after this many fitness evaluations

@item max-time
stop after this many seconds

@item target
stop when an individual passes @code{TARGET-FIT}

@item period
interval of fitness evaluations to run @code{PERIOD-FN}

@item period-fn
function to run every @code{PERIOD} fitness evaluations

@item every-fn
function to run before every fitness evaluation

@end table

In addition the @code{evolve} function takes an optional @code{filter}
keyword argument which when specified only includes individual for
which @code{FILTER} returns true, and the @code{mcmc} function takes
an optional @code{accept-fn} keyword argument which is a function of
current and new fitness that returns acceptance.

@node Components, Multi-objective Fitness, Implementation, Top
@chapter Components
@cindex components

The Software Evolution library is implemented in Common Lisp and is
intended for use in Common Lisp programs.  @ref{fig:overview} provides
an overview of the Software Evolution system, the specifics of which
are given in remainder of this section.

@menu
* Test Suites::                 Running unit tests
* Multi-objective Fitness::     Optimizing multiple objectives
* Style Features::              Extracting source code features
* Tokenizer::                   Tokenize software objects
* Condition Synthesis::         Repair technique to synthesize guard conditions
* Fault Localization::          Identifying or prioritizing likely-faulty code
* Tracing::                     Trace execution of software
@end menu

@node Test Suites, Multi-objective Fitness, Components, Components
@section Test Suites
@cindex test-suite
@include test-suite.texi

@node Multi-objective Fitness, Style Features, Test Suites, Components
@section Multi-objective Fitness
@cindex multi-objective fitness
@include multi-objective-fitness.texi

@node Style Features, Tokenizer, Multi-objective Fitness, Components
@section Style Features
@cindex style-features
@include style-features.texi

@node Tokenizer, Condition Synthesis, Style Features, Components
@section Tokenizer
@cindex tokenizer
@include tokenizer.texi

@node Condition Synthesis, Fault Localization, Tokenizer, Components
@section Condition Synthesis
@cindex condition-synthesis
@include condition-synthesis.texi

@node Fault Localization, Tracing, Condition Synthesis, Components
@section Fault Localization
@cindex fault-localization
@include fault-localization.texi

@node Tracing, Usage, Fault Localization, Components
@section Tracing
@cindex tracing
@include tracing.texi

@node Usage, Mutation, Implementation, Top
@chapter Usage
@cindex usage


@menu
* Installation:: Installing SEL and its dependencies
* Examples:: A series of examples demonstrating some SEL applications.

@end menu



@node Installation, Examples, Usage, Usage
@section Installation

The source code for the Software Evolution library is available at
@url{https://github.com/GrammaTech/sel}.  The following Common Lisp
packages are required by this library, all of which are installable
through Quicklisp (see @url{http://www.quicklisp.org/}).
@itemize
@item alexandria
@item metabang-bind
@item curry-compose-reader-macros
@item split-sequence
@item cl-ppcre
@item elf
@end itemize

Depending on the type of software object used the following may also
be required.
@itemize
@item
llvm-mutate for @code{llvm} object support (available from
@url{https://github.com/eschulte/llvm-mutate}).
@item
cil-mutate for @code{cil} object support (available from
@url{https://github.com/eschulte/cil-mutate}).
@item
clang-mutate for @code{clang} object support  (available from
@url{https://github.com/GrammaTech/clang-mutate}).
@end itemize

Install llvm-mutate, cil-mutate and clang-mutate as per the
instructions in their respective repository. (Note, it is only
necessary to install the tools for the specific software backends you
intend to use.) Install SEL by cloning the repository into your
quicklisp local-projects directory and then running:
@example
    (ql:register-local-projects)
    (ql:quickload :software-evolution-library)
    (ql:quickload :software-evolution-library/utility)
@end example




@node Examples, Mutation, Installation, Usage
@section Examples

The following examples demonstrate usage.

@menu
* Mutation::                    Mutate a given program
* Evaluation::                  Evaluate fitness of a mutant
* Neutral Variants::            Generate neutral variants of a program
* Repair::                      Program repair
* Parallel Repair::             Parallel program repair
@c * Memoize Fitness::             A global memoized genome-fitness map
@c * Annotations::                 Annotating portions of the genome
@c * Focused Mutation::            Using annotations to focus mutation operations
@c * Execution Statistics::        Saving statistics
@end menu

@node Mutation, Evaluation, Examples, Examples
@subsection Mutation
@cindex example mutation

The following example code;
@enumerate
@item loads an @code{asm} software object from a file,
@item mutates the object, and then
@item writes the a modified version of the object to disk
@item and prints the applied mutation.
@end enumerate

@verbatiminclude ./examples/001-mutate.lisp

Executing this code will print output resembling the following.

@example
Results of applying #<SIMPLE-CUT #<ASM #x3020022A24DD> 78> to gcd written to "/tmp/fileLfs6Mf.s".
@end example

@node Evaluation, Neutral Variants, Mutation, Examples
@subsection Evaluation
@cindex example evaluation

The example code below does the following.
@enumerate
@item
Defines a @code{test} function used to evaluate the fitness of a
software object.  This function makes use of an external shell script
test driver which is run using the @code{shell} function defined in
the @code{software-evolution-library/utility}.

@item
The original program is initialized from a file on disk.

@item
Ten mutants of the original are generated by applying random edits.

@item
The @code{fitness} field of each mutant is set using the previously
defined @code{test} method.

@item
The edits and fitness of each mutant are printed.

@end enumerate

@verbatiminclude ./examples/002-evaluation.lisp

Executing this code will print output resembling the following.

@c TODO: Figure out if/why this doesn't seem to work currently.

@example
 0 fitness for edit (:INSERT 76 38)
 0 fitness for edit (:SWAP 66 77)
 0 fitness for edit (:CUT 50)
10 fitness for edit (:CUT 11)
10 fitness for edit (:SWAP 62 39)
 0 fitness for edit (:INSERT 2 48)
10 fitness for edit (:CUT 66)
 0 fitness for edit (:CUT 73)
10 fitness for edit (:INSERT 73 26)
 0 fitness for edit (:INSERT 71 1)
@end example

@node Neutral Variants, Repair, Evaluation, Examples
@subsection Neutral Variants
@cindex neutral variants

Using the @code{test} function defined in the previous example
(@pxref{Evaluation}), the code block below generates a number of
variants of the original program which still satisfy the test suite,
known as ``neutral mutants'' (see @cite{Software Mutational
Robustness} available at @url{http://arxiv.org/abs/1204.4224}).

@verbatiminclude ./examples/003-neutral.lisp

@node Repair, Parallel Repair, Neutral Variants, Examples
@subsection Repair
@cindex repair

Using the @code{test} function defined in a previous example
(@pxref{Evaluation}), the code block below searches for a ``repair''
of the buggy gcd implementation in @code{test/etc/gcd/gcd.s}.  The
``repair'' will be a version of gcd which passes all 11 tests run in
@code{test}.

The @code{target} and @code{max-evals} keyword arguments are passed to
@code{evolve} (@pxref{evolve}).  These arguments terminate the
evolutionary search when either a repair has been reached or a budget
of fitness evaluations has been exhausted respectively.

The following properties of this example should be noted.

@enumerate
@item
Before calling @code{evolve} the population is populated with copies
of the original program.

@item
The @code{*orig*} individual is assigned a fitness before the
@code{*population*} is populated.  This is necessary as the search
functions assume that every element of @code{*population*} already
have a fitness assigned.

@item
The @code{*population*} is not explicitly passed to the @code{evolve}
function which implicitly modifies the @code{*population*} variable.
When this function terminates the evolved program variants will be
saved in the @code{*population*}.

@end enumerate

@verbatiminclude ./examples/004-evolve.lisp

@node Parallel Repair, SEL API Reference, Repair, Examples
@subsection Parallel Repair
@cindex parallel repair

Evolution may be parallelized by calling @code{evolve} in multiple
threads.  For example a parallel version of the above example would
replace,

@example
(let ((*target-fitness-p* [@{= 11@} #'fitness]))
  (evolve #'test :max-evals 100))
@end example

with the following.

@example
(require 'bordeaux-threads)
(defvar *num-threads* 64 "Number of available cores.")

;; launch *num-threads* evolution threads
(let ((*target-fitness-p* [@{= 11@} #'fitness]))
  (let (threads)
    (loop :for n :below *num-threads* :do
       (push (bordeaux-threads:make-thread
              (lambda () (evolve #'test :max-evals 100))
              :name (format nil "opt-~d" n))
             threads))))

;; wait for all threads to return
(mapc #'bordeaux-threads:join-thread threads)
@end example

@c @node Annotations, Focused Mutation, Parallel Fitness Evaluation, Usage Examples
@c @section Annotations
@c @cindex annotations

@c @node Focused Mutation, Execution Statistics, Annotations, Usage Examples
@c @section Focused Mutation
@c @cindex focused mutation

@c @node Execution Statistics, Memoize Fitness, Focused Mutation, Usage Examples
@c @section Execution Statistics
@c @cindex execution statistics

@c @node Memoize Fitness, Neutral Variants, Execution Statistics, Usage Examples
@c @section Memoize Fitness
@c @cindex memoize fitness


@node SEL API Reference, Troubleshooting, Usage, Top
@chapter SEL API Reference
@cindex api

@include api.texi


@node Troubleshooting, Utility, SEL API Reference, Top
@chapter Troubleshooting
@cindex troubleshooting

@include troubleshooting.texi


@node Utility, View, Usage, Top
@section Utility
@cindex utility

@include utility.texi



@node View, Test, Utility, Top
@section View
@cindex view

@include view.texi



@node Test, General Lisp Advice, View, Top
@section Test
@cindex test

@include test.texi



@node General Lisp Advice, Getting Started with Lisp, Test, Top
@appendix General Lisp Advice

@menu
* Getting Started with Lisp::
* Additional Lisp Resources::
* General Lisp Debugging Advice::
@end menu

@node Getting Started with Lisp, Additional Lisp Resources, General Lisp Advice, General Lisp Advice
@appendixsec Getting Started with Lisp

We recommend the following Common Lisp resources.

@itemize

@item
The @url{http://cliki.net/Getting+Started,Getting Started} guide provided on @url{http://cliki.net/,CLiki}, the Common Lisp wiki.

This is a fairly complete guide to starting out with Lisp in general
and Common Lisp in particular.

@item @url{http://www.gigamonkeys.com/book/,Practical Common Lisp}.

Especially, @url{
http://www.gigamonkeys.com/book/lather-rinse-repeat-a-tour-of-the-repl.html,
Chapter 2} describes how to get Emacs and Slime working.

@end itemize


We strongly recommend that you use Emacs: no other editor has such
strong integration into the Lisp process (useful for finding function
definitions, automatically displaying information, compiling,
highlighting compiler warnings, evaluating, etc...).
Install Emacs @url{http://emacswiki.org/emacs/ParEdit,ParEdit} for
additional Lisp authoring support.

If you prefer to use VIM, we recommend installing
@url{https://github.com/vim-scripts/paredit.vim,paredit.vim}.




@node Additional Lisp Resources, General Lisp Debugging Advice, Getting Started with Lisp, General Lisp Advice

@appendixsec Additional Lisp Resources

@itemize

@item
The @code{#lisp} IRC room on the @url{https://freenode.net/,freenode}
IRC server.


@item 
@url{http://www.cliki.net/slime-howto,Introduction to Slime}

@item
@url{https://www.emacswiki.org/emacs/ParEdit,Introduction to ParEdit}

@item
@url{https://melpa.org/#/getting-started,Introduction to Melpa}

@item
@url{http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/,Debugging Lisp}

@item
@url{http://www.gigamonkeys.com/book/,Practical Common Lisp Book}

@item
@url{https://www.csee.umbc.edu/courses/331/resources/lisp/onLisp/,On Lisp}

@item
@url{https://github.com/eschulte/curry-compose-reader-macros,
     Curry compose reader macros@comma{} aka@comma{} those weird @code{[@{@}]} and @code{«»} symbols}

@item
We prefer @code{iter} over @code{loop}. See
@url{https://sites.google.com/site/sabraonthehill/loop-v-iter#TOC-Collect,
     @code{loop} vs. @code{iter}} for a comparison.

@item
@url{https://common-lisp.net/project/iterate/doc/index.html,
     @code{iter} in detail}

@item
@url{https://common-lisp.net/project/metabang-bind/user-guide.html,
     Using @code{bind}}

@end itemize


@node General Lisp Debugging Advice, Licensing, Additional Lisp Resources, General Lisp Advice
@appendixsec General Lisp Debugging Advice


@subsection Log all interaction with the system shell

For problems related to the execution of external commands turn on
logging of all execution of shell commands by SEL.  This may be done
by setting the `*shell-debug*` variable to a non-nil value.

@lisp
(setq *shell-debug* t)
@end lisp

All subsequent executions of @code{shell} will now print logging
information.


@subsection Tracing specific functions

Common Lisp provides support for function-level tracing.  This may be
enabled and disabled using the @code{cl-user::trace} and
@code{cl-user::untrace} functions respectively, as shown in the
following.

@lisp
    CL-USER> (in-package :software-evolution-library/test)
    #<PACKAGE "SOFTWARE-EVOLUTION-LIBRARY/TEST">
    SE-TEST> (hello-world-clang)
    T
    SE-TEST> (cl-user::trace snippet->clang-type)
    (SNIPPET->CLANG-TYPE)
    SE-TEST> (update-asts *hello-world*)
      0: (SNIPPET->CLANG-TYPE
          ((:ARRAY . "") (:COL . 0) (:DECL . "") (:FILE . "")
           (:HASH . 342363981814211589) (:LINE . 0) (:POINTER . T) (:REQS)
           (:SIZE . 4) (:TYPE . "char")))
      0: SNIPPET->CLANG-TYPE returned
           #S(CLANG-TYPE
              :ARRAY ""
              :COL 0
    ;;;...
    #<CLANG @{1003AD88D3@}>
    SE-TEST>
@end lisp


@subsection Use extra verbosity in command-line tools

Many command-line tools compiled from @code{sel} support various levels of
verbosity in their output.  The simplest first step in debugging these
tools should be to maximize the level of verbosity, e.g. @code{-v 5}.


@node SEL Coding Standards, Use the compiler(s), General Lisp Advice, Top
@appendix SEL Coding Standards

@menu
* Use the compiler(s)::
* Whitespace::
* Comments::
* Use existing utility functions::
* Packages::
* Portability::
* Documentation::
* Don't use superfluous @code{let} or @code{let*} bindings::
* Map instead of iterate::
* Judicious use of arrow macros::
@end menu

Google's
@url{http://google.github.io/styleguide/lispguide.xml,Common Lisp guide}
is generally applicable.  Specifically the sections on
@url{http://google.github.io/styleguide/lispguide.xml#Formatting,Formatting}
and
@url{http://google.github.io/styleguide/lispguide.xml#Comment_semicolons,Comment semicolons}.

@node Use the compiler(s), Whitespace, SEL Coding Standards, SEL Coding Standards
@appendixsec Use the compiler(s)


All code should compile without warning in both SBCL and CCL.  Files
may easily be compiled from within Emacs by running @code{M-x
slime-compile-file} (which is typically bound to @code{C-c M-k}).  These
warnings are often useful and catch type errors and outright mistakes
that can easily slip through testing.  This will also ensure
@ref{Portability,portability}.


@node Whitespace, Comments, Use the compiler(s), SEL Coding Standards
@appendixsec Whitespace

@itemize
@item no tabs
@item no closing parenthesis on lines by themselves
@item indent everything as would GNU Emacs
@item typically only include vertical whitespace between top-level
   forms, sections of large functions may be demarcated by vertical
   whitespace but it is better to use smaller functions
@item no trailing whitespace
@item no whitespace following an open-paren
@end itemize


@node Comments, Use existing utility functions, Whitespace, SEL Coding Standards
@appendixsec Comments (number of semicolons matters)

@itemize
@item All comments should be complete sentences with capitalization and a period.
@item 3 (or 4) semicolons at the beginning of a line for block comments outside of any top level form
@item 2 semicolons for comments that appear between lines of code
@item 1 semicolon for comments that appear after code at the end of a line
@item vertical align end-of-line comments when possible
@item always use a space after the last semicolon and before comment text
@item In Emacs @code{M-;} inserts a comment of the appropriate type.
@end itemize

@node Use existing utility functions, Packages, Comments, SEL Coding Standards
@appendixsec Use existing utility functions (don't write your own)

Regardless of language you should look carefully for existing utility
functions before re-implementation (what you want probably already
exists!).  For common lisp in particular you should check the
following places before implementation of any utility.

@enumerate
@item Run @code{(apropos "thing")} in the repl.

@item Look in the
@url{http://www.lispworks.com/documentation/HyperSpec/Front/,hyperspec}
(this lookup is a simple key-combo from a slime mode and is worth
learning).  The hyperspec is a reference, good for lookup and bad for
browsing.

@item Check the
@url{https://common-lisp.net/project/alexandria/,Alexandria} package.

@item Check the @code{utilities} package of SEL.
@end enumerate


@node Packages, Portability, Use existing utility functions, SEL Coding Standards
@appendixsec Packages

Only use packages which are explicitly included in your current
package.  E.g., calling @code{cl-fad:foo} just because @code{cl-fad} happens to
be loaded in the lisp image every time you've run tests is @emph{not}
acceptable.  Instead the @code{:use} option to @code{defpackage} should
explicitly include the required package and if necessary @code{:shadow} and
@code{:shadowing-import-from} should be used to limit the symbols imported.


@node Portability, Documentation, Packages, SEL Coding Standards
@appendixsec Portability

All code should be portable across at least
@url{http://www.sbcl.org/,SBCL} and
@url{https://ccl.clozure.com/,CCL}.  Any code which is specific to a
particular implementation must be protected by @code{#+impl} guards.


@node Documentation, Don't use superfluous @code{let} or @code{let*} bindings, Portability, SEL Coding Standards
@appendixsec Documentation

@subsection For functions and methods

Write documentation strings for @emph{every} function @emph{always}.
Also, ensure every @code{defmethod} has a @code{defgeneric} which has
a documentation string.

@subsection For files and modules

Large new functional modules (e.g., a new file of code) should be
documented in the manual.  The SEL manual is located in the @code{doc/}
subdirectory and is written in texinfo.  Follow the example set by
existing documentation to add new sections to this manual.



@node Don't use superfluous @code{let} or @code{let*} bindings, Map instead of iterate, Documentation, SEL Coding Standards
@appendixsec Don't use superfluous @code{let} or @code{let*} bindings


Any @code{let*} which can be changed to a @code{let} should be changed
to a @code{let}.

Typically, if a let-bound variable is only used once it should not be
bound but instead its definition should replace its sole use.  This
is suggested because each variable binding forces every subsequent
reader to perform a dereference.  For example, this

@lisp
(let* ((subject (quick brown fox))
       (object (lazy dog))
       (sentence (The subject jumps over the object.)))
  sentence)
@end lisp

is harder to read than this.

@lisp
(The quick brown fox jumps over the lazy dog)
@end lisp

There are some exceptions to this rule.

@itemize

@item
If the variable is often used in debugging (printf or debugger) and it
thus matters that it is bound at that point in the code then this may
be acceptable.

@item
If the let-bound value appears as, lets say, the third argument to
some function the in-lining of the long calculation may obscure the
flow of the function with it's other arguments.

@item
If use of the let avoids horrible indentation issues then it may be
acceptable.

@end itemize

@node Map instead of iterate, Judicious use of arrow macros, Don't use superfluous @code{let} or @code{let*} bindings, SEL Coding Standards
@appendixsec Map instead of iterate


Generally @code{mapc}, @code{mapcar}, @code{mappend}, and
@code{reduce} should be preferred to use of the @code{iterate} macro
(which should itself be preferred to @code{loop} which should never be
used).  In general @code{iterate} should be limited to cases where
non-trivial accumulation variables or incremental state are needed.
Potentially there are cases where a straightforward @code{iterate} has
better indentation behavior, in which case it might be acceptable (but
I can't think of one now).


@node Judicious use of arrow macros, Licensing, Map instead of iterate, SEL Coding Standards
@appendixsec Judicious use of ``arrow'' (@code{->}, @code{->>}, etc...) macros

We sometimes over-use the @code{->} and @code{->>} macros.  These
@emph{typically} only make sense to chain multiple calls, not single
(or often double) nested call.  One exception here is to aid
indentation (avoid going over 80 characters) when regular nesting
would require contortionist indentation.  For example in the following
excerpt from our tests.  This


@lisp
    (is (equalp (->> (stmt-starting-with-text *collatz* "int collatz")
                     (function-body *collatz*))
                #|...|#))
@end lisp

is nicer than this.

@lisp
    (is (equalp (function-body
                 *collatz*
                 (stmt-starting-with-text *collatz* "int collatz"))
                #|...|#))
@end lisp



@node Licensing, Copying, SEL Coding Standards, Top
@appendix Licensing

@menu
* Copying::                     The GNU General Public License gives
                                you permission to redistribute GNU Emacs on
                                certain terms; it also explains that there is
                                no warranty.
* GNU Free Documentation License::  The license for this documentation.
@end menu


@node Copying, GNU Free Documentation License, Licensing, Licensing
@appendixsec GNU GENERAL PUBLIC LICENSE
@include gpl.texi

@node GNU Free Documentation License, Index, Copying, Licensing
@appendixsec GNU Free Documentation License
@include doclicense.texi

@node Index,  , Licensing, Top
@unnumbered Index

@c Combine all index (function variable type and concept) types into a
@c single index.
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex tp cp
@printindex cp

@bye
