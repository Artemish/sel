

@menu

* Mutations::
* Trace Collection::
@end menu




@node Mutations,,,SEL API Reference
@section Mutations

@subsection Adding new mutations

New mutations should derive from the most-relevant base class. To
define a new mutation from an existing base class, use

@lisp
(define-mutation new-mutation (base-mutation)
  ())
@end lisp

The mutation may be initialized with two functions; a targeter and
picker. The targeter is a function which, given a software object,
returns a list of mutation targets; this function defaults to
@code{pick-bad}. The picker is a function which, given a software
object, returns a random mutation target; this function defaults to a
random element returned by @code{pick-bad}.

After creating a software object and a mutation, use the
@code{apply-mutation} method to create a new mutant.



@node Trace Collection,,,SEL API Reference
@section Trace Collection

Software objects which need to support trace collection should include
an @code{instrument} method and derive from @code{traceable}.

The @code{instrument} method should inject logging into the software
object before each full statement; to avoid intermingling
instrumentation logs with program output, the instrumentation should
be printed to the file given by the @code{__SEL_TRACE_FILE} environment
variable. At a minimum, logging should include an AST counter (:C) and
variables in scope at the given point (:SCOPES). Currently, only
primitive types are instrumented.

As an example, consider the following program:

@example
int main(int argc, char** argv) @{
    printf("Hello, World!");
        return 0;
        @}
@end example


The trace returned will contain the following elements:

@example
(((:INPUT :BIN) (:TRACE ((:C . 4)  (:SCOPES ("argc" "int" 1 NIL)))
                        ((:C . 10) (:SCOPES ("argc" "int" 1 NIL))))))
@end example

To collect traces, pass an instrumented version of the software object
to the @code{collect-traces} method along with a test suite of test
cases you wish to execute on the instrumented object.
