                          Software Evolution
                          ==================

Author: Eric Schulte
Date: 2012-11-12 18:34:03 MST


Table of Contents
=================
1 Design
2 Usage


1 Design 
=========
  +-------------+    +-------------+    +--------+    +--------------+
  | interactive |    | distributed |    | repair |    | optimization |
  |-------------|    |  evolution  |    |--------|    |--------------|
  | live in the |    |-------------|    | fixing |    |   improve    |
  |   editor    |    |  using ZMQ  |    |  bugs  |    |  performance |
  +-------------+    +-------------+    +--------+    +--------------+ ...
         |                  |                |                 |
         +------------------+------+---------+-----------------+
                                   |
                                 +-+-+                   population functions
                                 | | |                   --------------------
 global variables         +------------------+           incorporate
 ----------------         |   *population*   |           evict
 *population*             |------------------|           tournament
 *max-population-size*    |      list of     |           mutate
 *tournament-size*        | software objects |           crossed
 *fitness-predicate*      +------------------+           new-individual
 *cross-chance*                    |                     evolve
 *fitness-evals*                 +-+-+
 *running*                       | | |                   software functions
                          +------------------+           --------------
                          | software object  |           genome
 evolve arguments         |------------------|           phenome
 ----------------         | edits,           |           evaluate
 max-evals                | fitness          |           copy
 max-time                 | ...              |           mutate
 max-inds                 +------------------+           crossover
 max-fit                            |                    edit-distance
 min-fit                            |
 pop-fn       +--------------+------+-------------+---------------+ ...
 ind-fn       |              |                    |               |
          +-------+  +---------------+  +-------------+  +----------------+
          | clang |  |      asm      |  |    lisp     |  |       cil      |
          +-------+  |---------------|  |-------------|  +----------------+
          | C AST |  | assembly code |  | lisp source |  | C Intermediate |
          +-------+  +---------------+  +-------------+  |    Language    |
                                                         +----------------+

The =*population*= is a global variable holding a list of evolving
software variants.  The evolutionary computation functions operate
directly on the =*population*= through the "population functions".
Exposure of the population through a global variable enables the user
to initialize the population in any way, and allows external functions
to monitor and interact with the population during evolution.  For
example [distributed.lisp] enables sharing of individuals between
multiple instances of evolution through two functions which interact
with the =*population*= variable directly.

Each software variant is an object whose class is a sub-class of the
general =software= class.  New representations are implemented through
sub-classing =software= and customizing the generic software functions
where necessary.

Parameterization of the EC algorithm is done through setting global
variables and through arguments to the =evolve= function.


[distributed.lisp]: https://github.com/eschulte/software-evolution/blob/master/evolution/distributed.lisp

2 Usage 
========
Licensed under the GPLV3, see the [COPYING] file in this directory for
more information.

1. Available using git from [github].

2. To begin, =cd= into the =test/gcd= directory and look around.
   $ ls -1
   gcd.c                   # <- original program
   gcd.s                   # <- compiled from gcd.c with gcc -S gcd.c
   repair-asm.lisp         # <- options to repair
   test.sh*                # <- test script used to exercise gcd variants

3. Repairs may be performed from an interactive lisp session, for
   example, through evaluating the forms in [repair-clang.lisp]

4. Running =make= in this directory will build a =soft-ev= command
   line utility allowing repair to be scripted from the command line
   using simple configuration files.  The help message of the
   =soft-ev= command line utility serves as a template configuration
   file.

5. Distributed evolution between multiple lisp process on one or many
   machines is enabled using the [∅MQ] socket library.  Additionally,
   because population initialization is left to the user, distributed
   EC algorithms may also be implemented externally.  See
   [second-run.lisp] for an example configuration file using an incoming
   population.







   [COPYING]: https://github.com/eschulte/software-evolution/blob/master/COPYING
   [github]: https://github.com/eschulte/software-evolution
   [repair-clang.lisp]: https://github.com/eschulte/software-evolution/blob/master/test/gcd/repair-clang.lisp
   [∅MQ]: http://www.zeromq.org
   [second-run.lisp]: https://github.com/eschulte/software-evolution/blob/master/test/gcd/second-run.lisp

