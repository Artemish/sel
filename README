# -*- org -*-
#+Title: (=soft-ev=) Software Evolution
#+Author: Eric Schulte
#+email: eschulte@cs.unm.edu
#+Options: toc:1

#+begin_center
enabling the evolution of extant software projects
#+end_center

* Design
:                                                             population functions
:  global variables                                           --------------------
:  ----------------            +--------------+               incorporate
:  *population*                | *population* |               evict
:  *max-population-size*       |--------------|               tournament
:  *tournament-size*           | list of soft |               mutate
:  *test-script*               |    objects   |               crossed
:  *pos-test-num*              +--------------+               new-individual
:  *neg-test-num*                      |                      evolve
:  *pos-test-mult*                   +-+-+                  
:  *neg-test-mult*                   | | |                    soft functions
:  *keep-source*             +------------------+             --------------
:  *cross-chance*            |       soft       |             copy
:  *fitness-evals*           |------------------|             fitness
:  *running*                 | exe              |             exe
:                            | genome (path)    |             delete-exe
:  evolve arguments          | fitness          |             from (from-bytes)
:  ----------------          | history          |             to (to-bytes)
:  max-evals                 +------------------+             good-ind
:  max-time                    |              |               bad-ind
:  max-inds                    |              |               good-place
:  max-fit             +------------+      +-----------+      bad-place
:  min-fit             |  soft-asm  |      | soft-ast  |      insert
:  pop-fn              |------------|      |-----------|      cut
:  ind-fn              | addr-map   |      | (pending) |      swap
:                      +------------+      +-----------+ ...  crossover

The =*population*= is a global variable holding a list of evolving
software variants.  The evolutionary computation functions operate
directly on the =*population*= through the "population functions".
Exposure of the population through a global variable enables to user
to initialize the population in any way, and allows external functions
to monitor and interact with the population during evolution.  For
example =soft-ev-zmq= enables sharing of individuals between multiple
instances of evolution through two "sharing" functions which
manipulate the population during evolution.

Each software variant is an object whose class is a sub-class of the
general =soft= class.  New representations are implemented through
sub-classing =soft= and customizing the generic "soft functions" where
necessary.

Parameterization of the EC algorithm is done through setting global
variables and through arguments to the =evolve= function.

* Usage
1. Available using git from =git://adaptive.cs.unm.edu/soft-ev.git=.

2. To begin, =cd= into the =soft-ev/gcd= directory and look around.
   : $ ls -1
   : gcd.c                   # <- original program
   : gcd.s                   # <- compiled from gcd.c with gcc -S gcd.c
   : repair.lisp             # <- options to repair
   : sample.neg              # <- oprofile trace of negative test execution
   : sample.pos              # <- oprofile trace of positive test execution
   : test.sh*                # <- test script used to exercise gcd variants

3. Repairs may be performed from an interactive lisp session, for
   example, through evaluating the forms in [[file:gcd/repair.lisp][repair.lisp]].

4. Running =make= in this directory will build a =soft-ev= command
   line utility allowing repair to be scripted from the command line
   using simple configuration files.  The help message of the
   =soft-ev= command line utility serves as a template configuration
   file.

5. Distributed evolution between multiple lisp process on one or many
   machines is enabled using the [[http://www.zeromq.org][âˆ…MQ]] socket library.  Additionally,
   because population initialization is left to the user, distributed
   EC algorithms may also be implemented externally.  See
   [[file:gcd/second-run.lisp][second-run.lisp]] for an example configuration file using an incoming
   population.

* Notes
The following are informal working and development notes.

** thread local global variables
In case we want to run multiple populations in separate threads.

This should be easy with =let= binding of global variables.

** remember the need to collect statistics
- number of test suite evaluations
- time spent in many different aspects of the program, e.g.,
  - compilation
  - test suite evaluation
  - mutation and population maintenance
  - total run time

** consider how weighted path information propagates with mutation operators
Each individual should have its own weight, possibly expressed as a
diff against some global weight.

Even better, we can just store each individuals weight as part of its
genome.  If memory does become an issue then diff fanciness can be
brought to bear later on.

** possibly re-calculate the weighted path with each test case run
Nope, this would involve instrumenting each individual at the AST
level, and would require multiple runs for sampling at the ASM/ELF
levels, better to just use a heuristic to update/maintain weights.

e.g., weight of a recently transplanted piece of code is equal to the
average of previous weight and weight of both new neighbors.

See the =*genome-averaging-keys*= variable.

** allow adding individuals on-the-fly
Implement all operations as one-offs against a local =*population*=, a
la [[http://cs.unm.edu/~treport/tr/11-04/paper-2011-01.pdf][PEC]].

** as basis for distributed GP repair
See above, shouldn't be too difficult.  Loosely follow the PEC
algorithm.

** timed EC operators at set frequencies
One frequency options should be "fast as possible", but allowing
frequencies could be good for known energy consumption (e.g., if
running on someone's phone).


* Tasks [0/6]
** TODO Flesh out the test suite [0/4]
- [ ] mutation operators
- [ ] copy returns a *new* and *equal* object
- [ ] fitness evaluation
- [ ] population addition and subtraction

** TODO add elf level representation
** TODO implement general tree-base mutation operations
** TODO add a lisp source-code level representation
** TODO add an =optimize= method
   :PROPERTIES:
   :CUSTOM_ID: multi-objective-optimization
   :END:
multi-objective optimization for things like speed and size

** TODO use optimization to evolve better FFT
Use [[#multi-objective-optimization][the =optimize= method]] to evolve a better FFT function along
dimensions such as
- power consumption
- running time
- communication overhead
