# -*- org -*-
#+Title: Software Evolution
#+Author: Eric Schulte
#+email: eschulte@cs.unm.edu
#+Options: toc:1
#+properties: exports code
#+HTML: <center>enabling the evolution of extant software projects</center>

* Design
:   +-------------+    +-------------+    +--------+    +--------------+
:   | interactive |    | distributed |    | repair |    | optimization |
:   |-------------|    |-------------|    |--------|    |--------------|
:   | live in the |    |  using ZMQ  |    | fixing |    |   improve    |
:   |   editor    |    |             |    |  bugs  |    |  performance |
:   +-------------+    +-------------+    +--------+    +--------------+ ...
:          |                  |                |                 |
:          +------------------+------+---------+-----------------+
:                                    |
:                                  +-+-+
:                                  | | |                   population functions
:  global variables           +--------------+             --------------------
:  ----------------           | *population* |             incorporate
:  *population*               |--------------|             evict
:  *max-population-size*      | list of soft |             tournament
:  *tournament-size*          |    objects   |             mutate
:  *cross-chance*             +--------------+             crossed
:  *fitness-evals*                   |                     new-individual
:  *running*                       +-+-+
:                                  | | |
:                           +------------------+
:                           |     software     |           software functions
:                           |------------------|           --------------
:                           | genome (& trace) |           copy
:   repair arguments        | fitness          |           evaluate
:   ----------------        | history          |           insert
:   max-evals               | ...              |           cut
:   max-time                +------------------+           swap
:   max-inds                          |                    crossover
:   max-fit                 +---------+---------+
:   min-fit                 |                   |
:   pop-fn          +---------------+     +-------------+
:   ind-fn          |      asm      |     |    lisp     |
:                   |---------------|     |-------------|
:                   | assembly code |     | lisp source |
:                   +---------------+     +-------------+ ...

The =*population*= is a global variable holding a list of evolving
software variants.  The evolutionary computation functions operate
directly on the =*population*= through the "population functions".
Exposure of the population through a global variable enables the user
to initialize the population in any way, and allows external functions
to monitor and interact with the population during evolution.  For
example [[file:evolution/distributed.lisp][distributed.lisp]] enables sharing of individuals between
multiple instances of evolution through two "sharing" functions which
interact with the =*population*= variable directly.

Each software variant is an object whose class is a sub-class of the
general =software= class.  New representations are implemented through
sub-classing =software= and customizing the generic "software
functions" where necessary.

Parameterization of the EC algorithm is done through setting global
variables and through arguments to the =evolve= function.

* Usage
Licensed under the GPLV3, see the [[file:COPYING][COPYING]] file in this directory for
more information.

1. Available using git from [[http://gitweb.adaptive.cs.unm.edu/software-evolution.git][git://adaptive.cs.unm.edu/software-evolution.git]].

2. To begin, =cd= into the =test/gcd= directory and look around.
   : $ ls -1
   : gcd.c                   # <- original program
   : gcd.s                   # <- compiled from gcd.c with gcc -S gcd.c
   : repair-asm.lisp         # <- options to repair
   : test.sh*                # <- test script used to exercise gcd variants

3. Repairs may be performed from an interactive lisp session, for
   example, through evaluating the forms in [[file:test/gcd/repair-asm.lisp][repair-asm.lisp]].

4. Running =make= in this directory will build a =soft-ev= command
   line utility allowing repair to be scripted from the command line
   using simple configuration files.  The help message of the
   =soft-ev= command line utility serves as a template configuration
   file.

5. Distributed evolution between multiple lisp process on one or many
   machines is enabled using the [[http://www.zeromq.org][âˆ…MQ]] socket library.  Additionally,
   because population initialization is left to the user, distributed
   EC algorithms may also be implemented externally.  See
   [[file:test/gcd/second-run.lisp][second-run.lisp]] for an example configuration file using an incoming
   population.

* Notes
The following are informal working and development notes.

** ensure mutation operations can be reapplied
So if say we know that a program was crossed over at point x, we
should be able to call crossover(x) separate form the whole evolution
framework.

** objects generalizations and interactions
:                       +--- evolution --- goals
:                       |
:                  population(s)
:                       |
: program --- representations----------- mutations ------ library/templates
:                       |                                         |
:                   evaluation                             version control

** thread local global variables
In case we want to run multiple populations in separate threads.

This should be easy with =let= binding of global variables.

** remember the need to collect statistics
- number of test suite evaluations
- time spent in many different aspects of the program, e.g.,
  - compilation
  - test suite evaluation
  - mutation and population maintenance
  - total run time

** consider how weighted path information propagates with mutation operators
Each individual should have its own weight, possibly expressed as a
diff against some global weight.

Even better, we can just store each individuals weight as part of its
genome.  If memory does become an issue then diff fanciness can be
brought to bear later on.

** possibly re-calculate the weighted path with each test case run
Nope, this would involve instrumenting each individual at the AST
level, and would require multiple runs for sampling at the ASM/ELF
levels, better to just use a heuristic to update/maintain weights.

e.g., weight of a recently transplanted piece of code is equal to the
average of previous weight and weight of both new neighbors.

See the =*genome-averaging-keys*= variable.

** allow adding individuals on-the-fly
Implement all operations as one-offs against a local =*population*=, a
la [[http://cs.unm.edu/~treport/tr/11-04/paper-2011-01.pdf][PEC]].

** as basis for distributed GP repair
See above, shouldn't be too difficult.  Loosely follow the PEC
algorithm.

** timed EC operators at set frequencies
One frequency options should be "fast as possible", but allowing
frequencies could be good for known energy consumption (e.g., if
running on someone's phone).

* Tasks [9/17]
** DONE cleanup files system [4/4]
- [X] combine soft.lisp and genome.lisp
- [X] use full names
- [X] remove the zmq-specific packaging and asd file
- [X] directory for evolutionary strategies?

** DONE switch soft-asm from lists to vectors
This will free up lists for CL source code.

** DONE Flesh out the test suite [4/4]
- [X] mutation operators
- [X] copy returns a *new* and *equal* object
- [X] fitness evaluation
- [X] population addition and subtraction

** DONE implement general tree-base operations
** DONE implement general list-based operations
** DONE fix bugs in list-based genome
- setf doesn't seem to have any effect because it is called on the
  constant data held in the variable rather than the variable itself

** DONE add a lisp source-code level representation
Should be able to repair the gcd algorithm.
file:test/gcd/repair-lisp.lisp

** DONE fix more bugs in lisp repair
it looks like evaluation and mutation and crossover are all throwing
errors, many of which are caused by that which should be a list not
being a list.

many `handler-case' statements are sprinkled through the code, update
these to write out offending genomes and functions to files for use in
future test cases

** DONE ensure that all proper lists stay proper lists in list genome mutation
** TODO add elf level representation
** TODO test external script repair at all three levels
** TODO add an =optimize= evolutionary method
   :PROPERTIES:
   :CUSTOM_ID: multi-objective-optimization
   :END:
- multi-objective optimization for things like speed and size
- should live in file:evolution/optimize.lisp

** TODO use optimization to evolve better FFT
Use [[#multi-objective-optimization][the =optimize= method]] to evolve a better FFT function along
dimensions such as
- power consumption
- running time
- communication overhead

** TODO look at interactive evolution of individual CL functions
The idea being to support an interactive development environment in
which the developer starts by associating some conditions with a
function, probably best to use a macro
#+begin_src lisp
  (defmacro defadapt (name args conditions &body body)
    (let ((func-name (gensym "function"))
          (condition (gensym "condition")))
      `(let ((,func-name (defun ,name ,args ,@body)))
         (dolist (,condition ,conditions)
           (setf (get ,func-name (first ,condition)) (second ,condition)))
         ,func-name)))

  (defadapt square-root (x)
      '((test (for-all ((n #'an-integer)
                        (r #'a-real))
                (is numberp (square-root n))
                (is numberp (square-root r))
                (only-if (> n 0) (is > (expt (square-root n) 2) 0))
                (only-if (> r 0) (is > (expt (square-root r) 2) 0))
                (only-if (>= n 0) (is < (- n (expt (square-root n) 2)) 0.001))
                (only-if (>= r 0) (is < (- r (expt (square-root r) 2)) 0.001)))))
    (sqrt x) #| ...rest of body... |#)

  (get 'square-root 'test)

  #+QuickCheck
  (quickcheck
    (for-all ((n #'an-integer)
              (r #'a-real))
      (is numberp (square-root n))
      (is numberp (square-root r))
      (only-if (> n 0) (is > (expt (square-root n) 2) 0))
      (only-if (> r 0) (is > (expt (square-root r) 2) 0))
      (only-if (>= n 0) (is < (- n (expt (square-root n) 2)) 0.001))
      (only-if (>= r 0) (is < (- r (expt (square-root r) 2)) 0.001))))
#+end_src

** TODO manipulate compiled lisp code
   :PROPERTIES:
   :CUSTOM_ID: lisp-asm
   :END:
Using the =disassemble= it is possible to access the compiled ASM of
lisp functions.

** TODO share assembly code between =soft-lisp= and =soft-asm=
After [[#lisp-asm][manipulate compiled lisp code]] is complete, it should then be
possible to share code between =soft-lisp= *and* =soft-asm= software
objects.  Just another =defmethod= on the =crossover= generic
function.
** TODO integrate with LLVM
see
- http://llvm.org/
- http://www.cliki.net/LLVM
- https://github.com/sellout/CL-LLVM -- install with quicklisp and
  work through the lisp version of the LLVM tutorial

Then look at [[http://llvm.org/docs/WritingAnLLVMPass.html][How to write a Pass]] for implementing this entire
technique as a compiler pass -- should have AST/IR manipulation in
there as well.

For parsing and manipulating LLVM IR, see [[http://stackoverflow.com/questions/9160509/how-do-i-parse-llvm-ir][how-do-i-parse-llvm-ir]].

* COMMENT Publishing
This code is used to publish this page to the =cs.unm.edu= webserver.
#+begin_src emacs-lisp :results silent
  (setq software-evolution-dir (file-name-directory (or load-file-name buffer-file-name)))
  (unless (boundp 'org-publish-project-alist)
    (setq org-publish-project-alist nil))
  ;; the main html page
  (add-to-list 'org-publish-project-alist
               `("software-evolution-html"
                  :base-directory ,software-evolution-dir
                  :include ("README")
                  :publishing-directory "/ssh:eschulte@moons.cs.unm.edu:~/public_html/code/software-evolution/"
                  :publishing-function org-publish-org-to-html
                  :style "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/
    .title  { text-align: center; }
    .todo   { color: red; }
    .done   { color: green; }
    .tag    { background-color: #add8e6; font-weight:normal }
    .timestamp { color: #bebebe; }
    .timestamp-kwd { color: #5f9ea0; }
    p.verse { margin-left: 3% }
    p { text-align: justify }
    pre {
      background: #232323;
      color: #e6e1dc;
      border: 1pt solid #AEBDCC;
      padding: 5pt;
      overflow: auto;
      display: table-cell;
    }
    table { border-collapse: collapse; }
    td, th { vertical-align: top; }
    dt { font-weight: bold; }
    div.figure { padding: 0.5em; }
    div.figure p { text-align: center; }
    .linenr { font-size:smaller }
    #content { max-width: 1000px; margin: auto; }
    /*]]>*/-->
  </style>"))
  ;; the contents of the base directory
  (add-to-list 'org-publish-project-alist
               `("software-evolution-data"
                 :base-directory ,software-evolution-dir
                 :include ("COPYING" "Makefile" "README")
                 :base-extension "lisp"
                 :publishing-directory "/ssh:eschulte@moons.cs.unm.edu:~/public_html/code/software-evolution/"
                 :publishing-function org-publish-attachment))
  ;; the contents of the lisp subdirectories
  (dolist (subdir '("software" "evolution"))
    (add-to-list 'org-publish-project-alist
                 `(,(concat "software-evolution-" subdir)
                   :base-directory ,(expand-file-name subdir software-evolution-dir)
                   :base-extension "lisp"
                   :publishing-directory ,(concat "/ssh:eschulte@moons.cs.unm.edu:~/public_html/code/software-evolution/"
                                                  subdir)
                   :publishing-function org-publish-attachment)))
  ;; a single combined project to publish both html and supporting materials
  (add-to-list 'org-publish-project-alist
               '("software-evolution" :components
                 ("software-evolution-html"
                  "software-evolution-data"
                  "software-evolution-software"
                  "software-evolution-evolution")))

#+end_src
